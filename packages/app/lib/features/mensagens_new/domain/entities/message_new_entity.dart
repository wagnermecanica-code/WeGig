import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'message_new_entity.freezed.dart';
part 'message_new_entity.g.dart';

/// Status de entrega da mensagem
enum MessageDeliveryStatus {
  /// Mensagem enviando (otimistic UI)
  sending,

  /// Mensagem enviada para o servidor
  sent,

  /// Mensagem entregue ao dispositivo do destinat√°rio
  delivered,

  /// Mensagem lida pelo destinat√°rio
  read,

  /// Falha no envio
  failed,
}

/// Tipo de mensagem
enum MessageType {
  /// Mensagem de texto simples
  text,

  /// Mensagem com imagem
  image,

  /// Mensagem de sistema (ex: "Fulano entrou na conversa")
  system,

  /// Mensagem deletada
  deleted,
}

/// Domain entity para Mensagem individual - Nova implementa√ß√£o
///
/// Suporta:
/// - Texto com emojis
/// - Imagens
/// - Rea√ß√µes (m√∫ltiplas por usu√°rio)
/// - Reply (responder mensagem)
/// - Edi√ß√£o de mensagem
/// - Status de entrega (sent/delivered/read)
/// - Mensagens de sistema
/// - Soft delete (para mim / para todos)
@freezed
class MessageNewEntity with _$MessageNewEntity {
  const MessageNewEntity._();

  const factory MessageNewEntity({
    /// ID √∫nico da mensagem no Firestore
    required String id,

    /// ID da conversa pai
    required String conversationId,

    /// UID do remetente (Firebase Auth)
    required String senderId,

    /// ProfileId do remetente
    required String senderProfileId,

    /// Nome do remetente (desnormalizado para performance)
    String? senderName,

    /// Foto do remetente (desnormalizado para performance)
    String? senderPhotoUrl,

    /// Conte√∫do textual da mensagem
    required String text,

    /// URL da imagem (se houver)
    String? imageUrl,

    /// Tipo da mensagem
    @Default(MessageType.text) MessageType type,

    /// Status de entrega
    @Default(MessageDeliveryStatus.sending) MessageDeliveryStatus status,

    /// Timestamp de cria√ß√£o
    required DateTime createdAt,

    /// Timestamp de edi√ß√£o (null se nunca editado)
    DateTime? editedAt,

    /// Se a mensagem foi editada
    @Default(false) bool isEdited,

    /// Rea√ß√µes: Map<profileId, emoji>
    @Default({}) Map<String, String> reactions,

    /// Dados da mensagem que est√° sendo respondida
    MessageReplyData? replyTo,

    /// Lista de profileIds que deletaram a mensagem "para mim"
    @Default([]) List<String> deletedForProfiles,

    /// Se a mensagem foi deletada para todos
    @Default(false) bool deletedForEveryone,

    /// Texto original (antes de deletar para todos)
    String? originalText,

    /// Metadados extras (extens√≠vel)
    @Default({}) Map<String, dynamic> metadata,
  }) = _MessageNewEntity;

  /// From Firestore Document
  factory MessageNewEntity.fromFirestore(
    DocumentSnapshot<Map<String, dynamic>> snapshot, {
    String? conversationId,
  }) {
    final data = snapshot.data();
    if (data == null) {
      throw Exception('MessageNewEntity: data is null for ${snapshot.id}');
    }

    return MessageNewEntity(
      id: snapshot.id,
      conversationId: conversationId ?? data['conversationId'] as String? ?? '',
      senderId: data['senderId'] as String? ?? '',
      senderProfileId: data['senderProfileId'] as String? ?? data['senderId'] as String? ?? '',
      senderName: data['senderName'] as String?,
      senderPhotoUrl: data['senderPhotoUrl'] as String?,
      text: data['text'] as String? ?? '',
      imageUrl: data['imageUrl'] as String?,
      type: _parseMessageType(data['type']),
      status: _parseDeliveryStatus(data['status']),
      createdAt: (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      editedAt: (data['editedAt'] as Timestamp?)?.toDate(),
      isEdited: data['isEdited'] as bool? ?? false,
      reactions: _parseReactions(data['reactions']),
      replyTo: data['replyTo'] != null
          ? MessageReplyData.fromMap(data['replyTo'] as Map<String, dynamic>)
          : null,
      deletedForProfiles:
          (data['deletedForProfiles'] as List<dynamic>?)?.cast<String>() ?? [],
      deletedForEveryone: data['deletedForEveryone'] as bool? ?? false,
      originalText: data['originalText'] as String?,
      metadata: (data['metadata'] as Map<String, dynamic>?) ?? {},
    );
  }

  /// From JSON - generated by freezed
  factory MessageNewEntity.fromJson(Map<String, dynamic> json) =>
      _$MessageNewEntityFromJson(json);

  /// Parse MessageType safely
  static MessageType _parseMessageType(dynamic data) {
    if (data == null) return MessageType.text;
    if (data is String) {
      return MessageType.values.firstWhere(
        (e) => e.name == data,
        orElse: () => MessageType.text,
      );
    }
    return MessageType.text;
  }

  /// Parse MessageDeliveryStatus safely
  static MessageDeliveryStatus _parseDeliveryStatus(dynamic data) {
    if (data == null) return MessageDeliveryStatus.sent;
    if (data is String) {
      return MessageDeliveryStatus.values.firstWhere(
        (e) => e.name == data,
        orElse: () => MessageDeliveryStatus.sent,
      );
    }
    return MessageDeliveryStatus.sent;
  }

  /// Parse reactions map safely
  static Map<String, String> _parseReactions(dynamic data) {
    if (data == null) return {};
    if (data is! Map) return {};
    return Map<String, String>.from(
      data.map((k, v) => MapEntry(k.toString(), v.toString())),
    );
  }

  // ============================================
  // GETTERS √öTEIS
  // ============================================

  /// Verifica se √© mensagem de imagem
  bool get hasImage => imageUrl != null && imageUrl!.isNotEmpty;

  /// Verifica se tem texto
  bool get hasText => text.isNotEmpty;

  /// Verifica se √© uma resposta a outra mensagem
  bool get isReply => replyTo != null;

  /// Verifica se tem rea√ß√µes
  bool get hasReactions => reactions.isNotEmpty;

  /// Verifica se √© mensagem de sistema
  bool get isSystemMessage => type == MessageType.system;

  /// Verifica se est√° deletada para todos
  bool get isDeletedForEveryone => deletedForEveryone || type == MessageType.deleted;

  /// Verifica se est√° deletada para um perfil espec√≠fico
  bool isDeletedForProfile(String profileId) {
    return deletedForProfiles.contains(profileId) || isDeletedForEveryone;
  }

  /// Verifica se √© do pr√≥prio usu√°rio
  bool isMine(String currentProfileId) {
    return senderProfileId == currentProfileId;
  }

  /// Preview da mensagem (para lista de conversas)
  String get preview {
    if (isDeletedForEveryone) return 'üö´ Mensagem apagada';
    if (type == MessageType.system) return text;
    if (hasImage && !hasText) return 'üì∑ Foto';
    if (hasText) {
      final trimmed = text.trim();
      return trimmed.length > 50 ? '${trimmed.substring(0, 50)}...' : trimmed;
    }
    return '';
  }

  /// Retorna lista de emojis de rea√ß√µes √∫nicas
  List<String> get uniqueReactionEmojis {
    return reactions.values.toSet().toList();
  }

  /// Retorna contagem de cada rea√ß√£o
  Map<String, int> get reactionCounts {
    final counts = <String, int>{};
    for (final emoji in reactions.values) {
      counts[emoji] = (counts[emoji] ?? 0) + 1;
    }
    return counts;
  }

  /// Retorna a rea√ß√£o de um perfil espec√≠fico (ou null)
  String? getReactionByProfile(String profileId) {
    return reactions[profileId];
  }

  /// Retorna lista de profileIds que reagiram com um emoji espec√≠fico
  List<String> getProfilesForReaction(String emoji) {
    return reactions.entries
        .where((e) => e.value == emoji)
        .map((e) => e.key)
        .toList();
  }

  /// ‚úÖ Verifica se a mensagem pode ser editada (at√© 15 minutos ap√≥s envio)
  bool canEdit(String currentProfileId) {
    // Apenas o autor pode editar
    if (senderProfileId != currentProfileId) return false;
    
    // Mensagens deletadas n√£o podem ser editadas
    if (isDeletedForEveryone) return false;
    
    // Mensagens de sistema n√£o podem ser editadas
    if (isSystemMessage) return false;
    
    // Limite de 15 minutos
    final now = DateTime.now();
    final timeSinceCreation = now.difference(createdAt);
    return timeSinceCreation.inMinutes < 15;
  }

  /// ‚úÖ Retorna o tempo restante para edi√ß√£o em minutos (null se n√£o pode editar)
  int? editTimeRemainingMinutes(String currentProfileId) {
    if (!canEdit(currentProfileId)) return null;
    
    final now = DateTime.now();
    final elapsed = now.difference(createdAt).inMinutes;
    return 15 - elapsed;
  }

  // ============================================
  // VALIDATION
  // ============================================

  /// Valida mensagem antes de enviar
  static String? validate(String text, String? imageUrl) {
    if (text.trim().isEmpty && (imageUrl == null || imageUrl.isEmpty)) {
      return 'Mensagem n√£o pode ser vazia';
    }
    if (text.length > 2000) {
      return 'Mensagem muito longa (m√°ximo 2000 caracteres)';
    }
    return null;
  }

  /// Sanitiza texto (preserva emojis, remove apenas caracteres de controle)
  static String sanitize(String text) {
    var sanitized = text.trim();
    // Remove m√∫ltiplas quebras de linha consecutivas (mant√©m 1)
    sanitized = sanitized.replaceAll(RegExp(r'\s*\n{3,}\s*'), '\n\n');
    // Remove caracteres de controle C0 (exceto \n e \t)
    sanitized =
        sanitized.replaceAll(RegExp(r'[\u0000-\u0008\u000B-\u001F\u007F]'), '');
    return sanitized;
  }

  // ============================================
  // TO FIRESTORE
  // ============================================

  /// To Firestore Document
  Map<String, dynamic> toFirestore() {
    return {
      'conversationId': conversationId,
      'senderId': senderId,
      'senderProfileId': senderProfileId,
      if (senderName != null) 'senderName': senderName,
      if (senderPhotoUrl != null) 'senderPhotoUrl': senderPhotoUrl,
      'text': text,
      if (imageUrl != null) 'imageUrl': imageUrl,
      'type': type.name,
      'status': status.name,
      'createdAt': Timestamp.fromDate(createdAt),
      if (editedAt != null) 'editedAt': Timestamp.fromDate(editedAt!),
      'isEdited': isEdited,
      'reactions': reactions,
      if (replyTo != null) 'replyTo': replyTo!.toMap(),
      'deletedForProfiles': deletedForProfiles,
      'deletedForEveryone': deletedForEveryone,
      if (originalText != null) 'originalText': originalText,
      if (metadata.isNotEmpty) 'metadata': metadata,
    };
  }
}

/// Dados da mensagem que est√° sendo respondida
@freezed
class MessageReplyData with _$MessageReplyData {
  const MessageReplyData._();

  const factory MessageReplyData({
    /// ID da mensagem original
    required String messageId,

    /// Texto da mensagem original (preview)
    required String text,

    /// ProfileId do autor da mensagem original
    required String senderProfileId,

    /// Nome do autor (desnormalizado)
    String? senderName,

    /// URL da imagem (se a mensagem original tinha imagem)
    String? imageUrl,
  }) = _MessageReplyData;

  /// From map
  factory MessageReplyData.fromMap(Map<String, dynamic> map) {
    return MessageReplyData(
      messageId: map['messageId'] as String? ?? '',
      text: map['text'] as String? ?? '',
      senderProfileId: map['senderProfileId'] as String? ?? '',
      senderName: map['senderName'] as String?,
      imageUrl: map['imageUrl'] as String?,
    );
  }

  factory MessageReplyData.fromJson(Map<String, dynamic> json) =>
      _$MessageReplyDataFromJson(json);

  /// To map
  Map<String, dynamic> toMap() {
    return {
      'messageId': messageId,
      'text': text,
      'senderProfileId': senderProfileId,
      if (senderName != null) 'senderName': senderName,
      if (imageUrl != null) 'imageUrl': imageUrl,
    };
  }

  /// Preview do texto (truncado)
  String get preview {
    if (imageUrl != null && text.isEmpty) return 'üì∑ Foto';
    if (text.length > 50) return '${text.substring(0, 50)}...';
    return text;
  }
}

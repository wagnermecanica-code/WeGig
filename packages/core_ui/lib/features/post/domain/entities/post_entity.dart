import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:core_ui/core/json_converters.dart';

part 'post_entity.freezed.dart';
part 'post_entity.g.dart';

/// Domain entity para Posts
/// Representa um post de músico ou banda procurando colaboradores
@freezed
class PostEntity with _$PostEntity {
  const PostEntity._();

  const factory PostEntity({
    required String id,
    required String authorProfileId,
    required String authorUid,
    required String content,
    @GeoPointConverter() required GeoPoint location,
    required String city,
    required String type,
    required String level,
    required List<String> instruments,
    required List<String> genres,
    required List<String> seekingMusicians,
    @TimestampConverter() required DateTime createdAt,
    @TimestampConverter() required DateTime expiresAt,
    String? neighborhood,
    String? state,
    String? photoUrl,
    String? youtubeLink,
    @Default([]) List<String> availableFor,
    double? distanceKm,
    String? authorName,
    String? authorPhotoUrl,
    String? activeProfileName,
    String? activeProfilePhotoUrl,
  }) = _PostEntity;

  /// From Firestore Document
  factory PostEntity.fromFirestore(
    DocumentSnapshot<Map<String, dynamic>> snapshot,
  ) {
    final data = snapshot.data();
    if (data == null) {
      throw Exception('Post data is null');
    }

    return PostEntity(
      id: snapshot.id,
      authorProfileId: data['authorProfileId'] as String? ?? '',
      authorUid: data['authorUid'] as String? ?? '',
      content: (data['content'] ?? data['message']) as String? ?? '',
      location: _parseGeoPoint(data['location']),
      city: data['city'] as String? ?? '',
      neighborhood: data['neighborhood'] as String?,
      state: data['state'] as String?,
      photoUrl: data['photoUrl'] as String?,
      youtubeLink: data['youtubeLink'] as String?,
      type: data['type'] as String? ?? 'musician',
      level: data['level'] as String? ?? '',
      instruments:
          (data['instruments'] as List<dynamic>?)?.cast<String>() ?? [],
      genres: (data['genres'] as List<dynamic>?)?.cast<String>() ?? [],
      seekingMusicians:
          (data['seekingMusicians'] as List<dynamic>?)?.cast<String>() ?? [],
      availableFor:
          (data['availableFor'] as List<dynamic>?)?.cast<String>() ?? [],
      createdAt: (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      expiresAt: (data['expiresAt'] as Timestamp?)?.toDate() ??
          DateTime.now().add(const Duration(days: 30)),
      distanceKm: (data['distanceKm'] as num?)?.toDouble(),
        authorName: data['authorName'] as String?,
        authorPhotoUrl: data['authorPhotoUrl'] as String?,
        activeProfileName: data['activeProfileName'] as String?,
        activeProfilePhotoUrl: data['activeProfilePhotoUrl'] as String?,
    );
  }

  /// From JSON - generated by freezed
  factory PostEntity.fromJson(Map<String, dynamic> json) =>
      _$PostEntityFromJson(json);

  /// Getters úteis
  double get latitude => location.latitude;
  double get longitude => location.longitude;

  bool get hasPhoto => photoUrl != null && photoUrl!.isNotEmpty;
  bool get hasYouTube => youtubeLink != null && youtubeLink!.isNotEmpty;
  bool get isExpired => DateTime.now().isAfter(expiresAt);

  /// To Firestore Document
  Map<String, dynamic> toFirestore() {
    return {
      'authorProfileId': authorProfileId,
      'authorUid': authorUid,
      'content': content,
      'location': location,
      'city': city,
      if (neighborhood != null) 'neighborhood': neighborhood,
      if (state != null) 'state': state,
      if (photoUrl != null) 'photoUrl': photoUrl,
      if (youtubeLink != null) 'youtubeLink': youtubeLink,
      'type': type,
      'level': level,
      'instruments': instruments,
      'genres': genres,
      'seekingMusicians': seekingMusicians,
      'availableFor': availableFor,
      if (authorName != null) 'authorName': authorName,
      if (authorPhotoUrl != null) 'authorPhotoUrl': authorPhotoUrl,
      if (activeProfileName != null) 'activeProfileName': activeProfileName,
      if (activeProfilePhotoUrl != null)
        'activeProfilePhotoUrl': activeProfilePhotoUrl,
      'createdAt': Timestamp.fromDate(createdAt),
      'expiresAt': Timestamp.fromDate(expiresAt),
    };
  }

  // To JSON - generated by freezed
  // toJson() is already generated by freezed
}

/// Accepts both GeoPoint and legacy map representations from older documents.
GeoPoint _parseGeoPoint(dynamic rawLocation) {
  if (rawLocation is GeoPoint) {
    return rawLocation;
  }

  if (rawLocation is Map<String, dynamic>) {
    final lat = _tryParseCoordinate(
      rawLocation['latitude'] ??
          rawLocation['_latitude'] ??
          rawLocation['lat'],
    );
    final lng = _tryParseCoordinate(
      rawLocation['longitude'] ??
          rawLocation['_longitude'] ??
          rawLocation['lng'],
    );
    if (lat != null && lng != null) {
      return GeoPoint(lat, lng);
    }
  }

  return const GeoPoint(0, 0);
}

double? _tryParseCoordinate(dynamic value) {
  if (value is num) return value.toDouble();
  if (value is String) return double.tryParse(value);
  return null;
}

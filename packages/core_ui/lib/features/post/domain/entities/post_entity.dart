import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:core_ui/core/json_converters.dart';

part 'post_entity.freezed.dart';
part 'post_entity.g.dart';

/// Domain entity para Posts
/// Representa um post de músico ou banda procurando colaboradores
@freezed
class PostEntity with _$PostEntity {
  const PostEntity._();

  const factory PostEntity({
    required String id,
    required String authorProfileId,
    required String authorUid,
    required String content,
    @GeoPointConverter() required GeoPoint location,
    required String city,
    required String type,
    required String level,
    required List<String> instruments,
    required List<String> genres,
    required List<String> seekingMusicians,
    @TimestampConverter() required DateTime createdAt,
    @TimestampConverter() required DateTime expiresAt,
    String? neighborhood,
    String? state,
    String? photoUrl, // Mantido para compatibilidade
    @Default([]) List<String> photoUrls, // NOVO: Lista de fotos (até 4)
    String? youtubeLink,
    @Default([]) List<String> availableFor,
    double? distanceKm,
    String? authorName,
    String? authorPhotoUrl,
    String? activeProfileName,
    String? activeProfilePhotoUrl,
    // Sales-specific fields
    String? title,
    String? salesType,
    double? price,
    String? discountMode,
    double? discountValue,
    @TimestampConverter() DateTime? promoStartDate,
    @TimestampConverter() DateTime? promoEndDate,
    String? whatsappNumber,
  }) = _PostEntity;

  /// From Firestore Document
  factory PostEntity.fromFirestore(
    DocumentSnapshot<Map<String, dynamic>> snapshot,
  ) {
    final data = snapshot.data();
    if (data == null) {
      throw Exception('Post data is null');
    }

    return PostEntity(
      id: snapshot.id,
      authorProfileId: data['authorProfileId'] as String? ?? '',
      authorUid: data['authorUid'] as String? ?? '',
      content: (data['content'] ?? data['message']) as String? ?? '',
      location: _parseGeoPoint(data['location']),
      city: data['city'] as String? ?? '',
      neighborhood: data['neighborhood'] as String?,
      state: data['state'] as String?,
      photoUrl: data['photoUrl'] as String?,
      photoUrls: (data['photoUrls'] as List<dynamic>?)?.cast<String>() ?? 
          (data['photoUrl'] != null ? [data['photoUrl'] as String] : []), // Compatibilidade
      youtubeLink: data['youtubeLink'] as String?,
      type: data['type'] as String? ?? 'musician',
      level: data['level'] as String? ?? '',
      instruments:
          (data['instruments'] as List<dynamic>?)?.cast<String>() ?? [],
      genres: (data['genres'] as List<dynamic>?)?.cast<String>() ?? [],
      seekingMusicians:
          (data['seekingMusicians'] as List<dynamic>?)?.cast<String>() ?? [],
      availableFor:
          (data['availableFor'] as List<dynamic>?)?.cast<String>() ?? [],
      createdAt: (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      expiresAt: (data['expiresAt'] as Timestamp?)?.toDate() ??
          DateTime.now().add(const Duration(days: 30)),
      distanceKm: (data['distanceKm'] as num?)?.toDouble(),
      authorName: data['authorName'] as String?,
      authorPhotoUrl: data['authorPhotoUrl'] as String?,
      activeProfileName: data['activeProfileName'] as String?,
      activeProfilePhotoUrl: data['activeProfilePhotoUrl'] as String?,
      // Sales-specific fields
      title: data['title'] as String?,
      salesType: data['salesType'] as String?,
      price: (data['price'] as num?)?.toDouble(),
      discountMode: data['discountMode'] as String?,
      discountValue: (data['discountValue'] as num?)?.toDouble(),
      promoStartDate: (data['promoStartDate'] as Timestamp?)?.toDate(),
      promoEndDate: (data['promoEndDate'] as Timestamp?)?.toDate(),
      whatsappNumber: data['whatsappNumber'] as String?,
    );
  }

  /// From JSON - generated by freezed
  factory PostEntity.fromJson(Map<String, dynamic> json) =>
      _$PostEntityFromJson(json);

  /// Getters úteis
  double get latitude => location.latitude;
  double get longitude => location.longitude;

  bool get hasPhoto => photoUrls.isNotEmpty || (photoUrl != null && photoUrl!.isNotEmpty);
  bool get hasYouTube => youtubeLink != null && youtubeLink!.isNotEmpty;
  bool get isExpired => DateTime.now().isAfter(expiresAt);
  
  /// Retorna primeira foto (para compatibilidade com código existente)
  String? get firstPhotoUrl => photoUrls.isNotEmpty ? photoUrls.first : photoUrl;

  /// To Firestore Document
  Map<String, dynamic> toFirestore() {
    return {
      'authorProfileId': authorProfileId,
      'authorUid': authorUid,
      'content': content,
      'location': location,
      'city': city,
      if (neighborhood != null) 'neighborhood': neighborhood,
      if (state != null) 'state': state,
      if (photoUrl != null) 'photoUrl': photoUrl,
      if (photoUrls.isNotEmpty) 'photoUrls': photoUrls,
      if (youtubeLink != null) 'youtubeLink': youtubeLink,
      'type': type,
      'level': level,
      'instruments': instruments,
      'genres': genres,
      'seekingMusicians': seekingMusicians,
      'availableFor': availableFor,
      if (authorName != null) 'authorName': authorName,
      if (authorPhotoUrl != null) 'authorPhotoUrl': authorPhotoUrl,
      if (activeProfileName != null) 'activeProfileName': activeProfileName,
      if (activeProfilePhotoUrl != null)
        'activeProfilePhotoUrl': activeProfilePhotoUrl,
      'createdAt': Timestamp.fromDate(createdAt),
      'expiresAt': Timestamp.fromDate(expiresAt),
      // Sales-specific fields
      if (title != null) 'title': title,
      if (salesType != null) 'salesType': salesType,
      if (price != null) 'price': price,
      if (discountMode != null) 'discountMode': discountMode,
      if (discountValue != null) 'discountValue': discountValue,
      if (promoStartDate != null) 'promoStartDate': Timestamp.fromDate(promoStartDate!),
      if (promoEndDate != null) 'promoEndDate': Timestamp.fromDate(promoEndDate!),
      if (whatsappNumber != null) 'whatsappNumber': whatsappNumber,
    };
  }

  // To JSON - generated by freezed
  // toJson() is already generated by freezed
}

/// Accepts both GeoPoint and legacy map representations from older documents.
GeoPoint _parseGeoPoint(dynamic rawLocation) {
  if (rawLocation is GeoPoint) {
    return rawLocation;
  }

  if (rawLocation is Map<String, dynamic>) {
    final lat = _tryParseCoordinate(
      rawLocation['latitude'] ??
          rawLocation['_latitude'] ??
          rawLocation['lat'],
    );
    final lng = _tryParseCoordinate(
      rawLocation['longitude'] ??
          rawLocation['_longitude'] ??
          rawLocation['lng'],
    );
    if (lat != null && lng != null) {
      return GeoPoint(lat, lng);
    }
  }

  return const GeoPoint(0, 0);
}

double? _tryParseCoordinate(dynamic value) {
  if (value is num) return value.toDouble();
  if (value is String) return double.tryParse(value);
  return null;
}

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'conversation_entity.freezed.dart';
part 'conversation_entity.g.dart';

/// Domain entity para Conversas (chat 1:1)
/// Suporta multi-perfil: cada perfil pode ter conversas independentes
@freezed
class ConversationEntity with _$ConversationEntity {
  const ConversationEntity._();

  const factory ConversationEntity({
    required String id,
    required List<String> participants,
    required List<String> participantProfiles,
    required String lastMessage,
    required DateTime lastMessageTimestamp,
    required Map<String, int> unreadCount,
    required DateTime createdAt,
    @Default([]) @JsonKey(includeFromJson: false, includeToJson: false) List<Map<String, dynamic>> participantProfilesData,
    @Default(false) bool archived,
    @Default(<String>[]) List<String> archivedProfileIds,
    DateTime? updatedAt,
  }) = _ConversationEntity;

  /// From Firestore Document
  /// Optional [profilesData] can be provided to enrich entity with full profile info
  factory ConversationEntity.fromFirestore(
    DocumentSnapshot<Map<String, dynamic>> snapshot, {
    List<Map<String, dynamic>>? profilesData,
  }) {
    final data = snapshot.data();
    if (data == null) {
      throw Exception('Conversation data is null');
    }

    return ConversationEntity(
      id: snapshot.id,
      participants:
          (data['participants'] as List<dynamic>?)?.cast<String>() ?? [],
      participantProfiles:
          (data['participantProfiles'] as List<dynamic>?)?.cast<String>() ?? [],
      participantProfilesData: profilesData ?? const [],
      lastMessage: data['lastMessage'] as String? ?? '',
      lastMessageTimestamp:
          (data['lastMessageTimestamp'] as Timestamp?)?.toDate() ??
              DateTime.now(),
      unreadCount: Map<String, int>.from((data['unreadCount'] as Map?)?.map(
              (k, v) => MapEntry(k.toString(), (v as num?)?.toInt() ?? 0)) ??
          {}),
      archived: data['archived'] as bool? ?? false,
      archivedProfileIds:
          (data['archivedProfileIds'] as List<dynamic>?)?.cast<String>() ??
              const <String>[],
      createdAt: (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      updatedAt: (data['updatedAt'] as Timestamp?)?.toDate(),
    );
  }

  /// From JSON - generated by freezed
  factory ConversationEntity.fromJson(Map<String, dynamic> json) =>
      _$ConversationEntityFromJson(json);

  /// Retorna unread count para um profileId especÃ­fico
  int getUnreadCountForProfile(String profileId) {
    return unreadCount[profileId] ?? 0;
  }

  /// Retorna o outro participante (profileId) dado o profileId atual
  String? getOtherParticipantProfileId(String currentProfileId) {
    try {
      return participantProfiles.firstWhere(
        (id) => id != currentProfileId,
      );
    } catch (e) {
      return null;
    }
  }

  /// Retorna o outro participante (UID) dado o UID atual
  String? getOtherParticipantUid(String currentUid) {
    try {
      return participants.firstWhere(
        (id) => id != currentUid,
      );
    } catch (e) {
      return null;
    }
  }

  /// To Firestore Document
  Map<String, dynamic> toFirestore() {
    return {
      'participants': participants,
      'participantProfiles': participantProfiles,
      'lastMessage': lastMessage,
      'lastMessageTimestamp': Timestamp.fromDate(lastMessageTimestamp),
      'unreadCount': unreadCount,
      'archived': archived,
      'archivedProfileIds': archivedProfileIds,
      'createdAt': Timestamp.fromDate(createdAt),
      if (updatedAt != null) 'updatedAt': Timestamp.fromDate(updatedAt!),
    };
  }

  /// To JSON - generated by freezed
  // toJson() is already generated by freezed
}

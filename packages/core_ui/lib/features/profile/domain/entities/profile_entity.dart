import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:core_ui/core/json_converters.dart';
import 'profile_type.dart';

part 'profile_entity.freezed.dart';
part 'profile_entity.g.dart';

/// Profile Entity - Immutable profile representation with Freezed
@freezed
class ProfileEntity with _$ProfileEntity {
  const ProfileEntity._();

  /// Creates a new ProfileEntity
  const factory ProfileEntity({
    required String profileId,
    required String uid,
    required String name,
    String? username,
    @Deprecated('Use profileType instead') required bool isBand,
    @Default(ProfileType.musician) ProfileType profileType,
    required String city,
    @GeoPointConverter() required GeoPoint location,
    @TimestampConverter() required DateTime createdAt,
    @Default(20.0) double notificationRadius,
    @Default(true) bool notificationRadiusEnabled,
    String? photoUrl,
    int? birthYear,
    String? bio,
    List<String>? instruments,
    List<String>? genres,
    String? level,
    String? instagramLink,
    String? tiktokLink,
    String? youtubeLink,
    String? neighborhood,
    String? state,
    List<String>? bandMembers,
    // Space-specific fields
    String? spaceType,
    String? phone,
    String? operatingHours,
    String? website,
    List<String>? amenities,
    @NullableTimestampConverter() DateTime? updatedAt,
  }) = _ProfileEntity;

  /// Creates ProfileEntity from Firestore document
  factory ProfileEntity.fromFirestore(
    DocumentSnapshot<Map<String, dynamic>> snapshot,
  ) {
    final data = snapshot.data()!;

    // Helper para converter Timestamp
    DateTime parseTimestamp(dynamic value) {
      if (value is Timestamp) return value.toDate();
      if (value is String) return DateTime.parse(value);
      if (value is int) return DateTime.fromMillisecondsSinceEpoch(value);
      return DateTime.now();
    }

    // Helper para converter GeoPoint
    GeoPoint parseGeoPoint(dynamic value) {
      if (value is GeoPoint) return value;
      if (value is Map) {
        final map = value as Map<String, dynamic>;
        if (map.containsKey('_latitude') && map.containsKey('_longitude')) {
          return GeoPoint(
            (map['_latitude'] as num).toDouble(),
            (map['_longitude'] as num).toDouble(),
          );
        }
        if (map.containsKey('latitude') && map.containsKey('longitude')) {
          return GeoPoint(
            (map['latitude'] as num).toDouble(),
            (map['longitude'] as num).toDouble(),
          );
        }
      }
      return const GeoPoint(0, 0);
    }

    // Parse profile type with backward compatibility
    ProfileType parseProfileType() {
      if (data.containsKey('profileType')) {
        return ProfileType.fromString(data['profileType'] as String);
      }
      // Backward compatibility: use isBand field
      final isBand = (data['isBand'] as bool?) ?? false;
      return isBand ? ProfileType.band : ProfileType.musician;
    }

    return ProfileEntity(
      profileId: snapshot.id,
      uid: (data['uid'] as String?) ?? '',
      name: (data['name'] as String?) ?? '',
      username: data['username'] as String?,
      isBand: (data['isBand'] as bool?) ?? false,
      profileType: parseProfileType(),
      city: (data['city'] as String?) ?? '',
      location: parseGeoPoint(data['location']),
      createdAt: parseTimestamp(data['createdAt']),
      notificationRadius:
          (data['notificationRadius'] as num?)?.toDouble() ?? 20.0,
      notificationRadiusEnabled:
          (data['notificationRadiusEnabled'] as bool?) ?? true,
      photoUrl: data['photoUrl'] as String?,
      birthYear: data['birthYear'] as int?,
      bio: data['bio'] as String?,
      instruments: (data['instruments'] as List<dynamic>?)?.cast<String>(),
      genres: (data['genres'] as List<dynamic>?)?.cast<String>(),
      level: data['level'] as String?,
      instagramLink: data['instagramLink'] as String?,
      tiktokLink: data['tiktokLink'] as String?,
      youtubeLink: data['youtubeLink'] as String?,
      neighborhood: data['neighborhood'] as String?,
      state: data['state'] as String?,
      bandMembers: (data['bandMembers'] as List<dynamic>?)?.cast<String>(),
      spaceType: data['spaceType'] as String?,
      phone: data['phone'] as String?,
      operatingHours: data['operatingHours'] as String?,
      website: data['website'] as String?,
      amenities: (data['amenities'] as List<dynamic>?)?.cast<String>(),
      updatedAt:
          data['updatedAt'] != null ? parseTimestamp(data['updatedAt']) : null,
    );
  }

  /// Creates ProfileEntity from JSON - generated by freezed
  factory ProfileEntity.fromJson(Map<String, dynamic> json) =>
      _$ProfileEntityFromJson(json);

  /// Converts ProfileEntity to Firestore map (without profileId)
  Map<String, dynamic> toFirestore() {
    final json = toJson();
    json.remove('profileId'); // ID vai no documento, não no data
    
    // Add profileType as string
    json['profileType'] = profileType.value;
    
    // Maintain backward compatibility
    json['isBand'] = profileType == ProfileType.band;
    
    if (json['username'] is String &&
        (json['username'] as String).trim().isNotEmpty) {
      json['usernameLowercase'] =
          (json['username'] as String).trim().toLowerCase();
    } else {
      json.remove('usernameLowercase');
    }
    return json;
  }

  /// Versão resumida para array em users/{uid}.profiles
  Map<String, dynamic> toSummary() {
    return {
      'profileId': profileId,
      'name': name,
      'photoUrl': photoUrl,
      'type': profileType.value,
      'city': city,
    };
  }

  // Computed properties (getters)
  int? get age {
    if (birthYear == null) return null;
    return DateTime.now().year - birthYear!;
  }

  String get ageLabel {
    switch (profileType) {
      case ProfileType.band:
        return 'Tempo de formação';
      case ProfileType.space:
        return 'Ano de fundação';
      case ProfileType.musician:
      default:
        return 'Idade';
    }
  }

  /// Calcula idade (músicos) ou tempo de formação (bandas) em anos
  int? get ageOrYearsSinceFormation {
    if (birthYear == null) return null;
    return DateTime.now().year - birthYear!;
  }

  /// Texto formatado: "25 anos" ou "5 anos de formação"
  String? get ageOrFormationText {
    final years = ageOrYearsSinceFormation;
    if (years == null) return null;
    switch (profileType) {
      case ProfileType.band:
        return years == 1 ? '$years ano de formação' : '$years anos de formação';
      case ProfileType.space:
        return years == 1 ? '$years ano de fundação' : '$years anos de fundação';
      case ProfileType.musician:
      default:
        return years == 1 ? '$years ano' : '$years anos';
    }
  }

  /// Check if profile is a musician
  bool get isMusician => profileType == ProfileType.musician;

  /// Check if profile is a band (kept for backward compatibility)
  bool get isBandProfile => profileType == ProfileType.band;

  /// Check if profile is a space
  bool get isSpace => profileType == ProfileType.space;

  double get latitude => location.latitude;
  double get longitude => location.longitude;
}
